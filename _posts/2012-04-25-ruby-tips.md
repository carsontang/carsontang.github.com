---
layout: post
title: "Ruby Tips"
category: Ruby
tags: [Ruby]
---
{% include JB/setup %}

#### Helpful Command-Line Flags
<br />
The `-c` and `-w` command-line flags for ruby mean _check for syntax errors_ and _check for questionable Ruby_,
respectively.

    ruby -cw program.rb

#### The difference between "load" and "require"
<br />
Semantically speaking, you _load_ a file, but you _require_ a feature. Also, _require_ doesn't reload
files, but _load_ does, if it's called again.

#### The difference between instance method and method
{% highlight ruby %}
String.instance_methods == "abc".methods    # => true
String.methods == "abc".methods             # => false
{% endhighlight %}

#### Search for a method
<br />

I sometimes switch from programming in C# to Python to Java to Ruby (not all in one day!). Just like learning Spanish and Italian, it's easy to mix up which word belongs to which language. In the case of programming languages, it's easy to forget, does a String class in Ruby use the length or size method? Use the following snippet to search for methods within a class.

{% highlight ruby %}
String.instance_methods(false).grep(/size|length/)
{% endhighlight %}

The code above says for the String class, return to me all instance methods and don't give me the ones that it's inherited from ancestor classes. Within that array of instance methods, find a symbol that contains the word size or the word length.

Fortunately, since one of the core principle's of Ruby's philosophy is to make programmers happy, Ruby contains both String#size and String#length.

#### Ruby's private keyword
<br />
Ruby's private keyword is different from C++ and Java's private keyword. The "private rule",
from Paolo Perrotta's excellent Metaprogramming Ruby: Program Like the Ruby Pros, states that
a private method comes about from two rules acting together

1) in order to call a method on an object that is NOT yourself, you need to specify explicitly the receiver

2) private methods can only be called with an implicit receiver

As a corollary, you can't call a private method on an object even with self as the explicit receiver.

Let's see this rule in action:
{% highlight ruby %}
class Dog
  def bark
    puts "bark"
  end

  private
  def disassociate_from_other_dogs
    puts "disassociate from other dogs"
  end
end

# in console
> self
=> main
> dog = Dog.new
=> #<Dog:0x007fd5010e4628>
> dog.disassociate_from_other_dogs
NoMethodError: private method `disassociate_from_other_dogs' called for #<Dog:0x007fd5010e4628>
> 
{% endhighlight %}

Why couldn't we call disassociate_from_other_dogs on dog? Let's apply the rule! self, refers to "main", so the object dog is not yourself. Thus, in order to call a method on dog, we need to specify the receiver explicitly.
Okay, we've specified we're calling the method on dog. However, disassociate_from_other_dogs is a private method. According to the second rule, private methods can only be called with an implicit receiver. But we're explicitly specifying the object. So why don't we implicitly specify the object is dog? We can't because self refers to main. Thus, we can't call the private method on dog.

There is a way to call an object's private method: simply use the Object#send method that all objects inherit.
{% highlight ruby %}
> dog.send(:disassociate_from_other_dogs)
{% endhighlight %}

But this violates the rule! Honestly, I don't know what to make of this, but it seems the [Ruby core contributors don't either](http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/7404).